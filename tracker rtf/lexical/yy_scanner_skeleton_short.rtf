{\rtf1\ansi\ansicpg1252\deflang1033{\fonttbl{\f0\fscript\fcharset0 Courier;}}{\colortbl ;\red0\green0\blue0;\red255\green255\blue255;\red128\green0\blue0;\red0\green0\blue255;\red0\green128\blue0;\red0\green0\blue128;}
{\cf3\f0\fs16 {\tab}{\tab}{\tab}-- Automatic generation produced by ISE Eiffel --
{\line}
{{\b\cf6 note}{\line}
{\tab}{\cf1 description}{\cf1 :} "Skeletons of scanners implemented with tables"{\line}
{\tab}{\cf1 library}{\cf1 :} "Gobo Eiffel Lexical Library"{\line}
{\tab}{\cf1 copyright}{\cf1 :} "Copyright (c) 2001-2016, Eric Bezault and others"{\line}
{\tab}{\cf1 license}{\cf1 :} "MIT License"{\line}
{\tab}{\cf1 date}{\cf1 :} "$Date: 2016-05-06 12:15:38 -0700 (Fri, 06 May 2016) $"{\line}
{\tab}{\cf1 revision}{\cf1 :} "$Revision: 98678 $"{\line}
{\line}
{\b\cf6 deferred} {\b\cf6 class} {\b\cf6 interface}{\line}
{\tab}{\cf4 YY_SCANNER_SKELETON}{\line}
{\line}
{\b\cf6 feature} {\cf3 --}{\cf3  Initialization}{\line}
{\line}
{\tab}{\cf5 {\cf5 reset}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  Reset scanner before scanning next input source.}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  (This routine can be called in }{\cf5 wrap}{\cf3  before scanning}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  another input buffer.)}{\line}
}{\line}
{\tab}{\cf5 {\cf5 reset_start_condition}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  Clear pushed start conditions and set }{\cf5 start_condition}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  to the "INITIAL" start condition.}{\line}
}{\tab}{\line}
{\b\cf6 feature} {\cf3 --}{\cf3  Access}{\line}
{\line}
{\tab}{\cf5 {\cf5 text}{\cf1 :} {\cf4 STRING_8}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  Text of last token read}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  (Create a new string at each call.)}{\line}
}{\line}
{\tab}{\cf5 {\cf5 text_item} {\cf1 (}{\cf5 i}{\cf1 :} {\cf4 INTEGER_32}{\cf1 )}{\cf1 :} {\cf4 CHARACTER_8}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  }{\cf5 i}{\cf3 -th character of last token read}{\line}
}{\line}
{\tab}{\cf5 {\cf5 text_substring} {\cf1 (}{\cf5 s}{\cf1 ,} {\cf5 e}{\cf1 :} {\cf4 INTEGER_32}{\cf1 )}{\cf1 :} {\cf4 STRING_8}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  Substring of last token read}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  (Create a new string at each call.)}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  (For efficiency reason, this function bypasses the}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  call to }{\cf5 text}{\cf3  and creates the substring directly}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  from the input buffer.)}{\line}
}{\line}
{\tab}{\cf5 {\cf5 start_condition}{\cf1 :} {\cf4 INTEGER_32}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  Start condition}{\line}
{\tab}{\tab}{\b\cf6 ensure then}{\line}
{\tab}{\tab}{\tab}{\cf1 definition}{\cf1 :} {\b\cf6 Result} {\cf1 =} {\cf1 (}{\cf5 yy_start_state} {\cf1 -} 1{\cf1 )} {\cf1 //} 2{\line}
}{\tab}{\line}
{\b\cf6 feature} {\cf3 --}{\cf3  Measurement}{\line}
{\line}
{\tab}{\cf5 {\cf5 text_count}{\cf1 :} {\cf4 INTEGER_32}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  Number of characters in last token read}{\line}
}{\line}
{\tab}{\cf5 {\cf5 line}{\cf1 :} {\cf4 INTEGER_32}}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  Line number of last token read when}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  '%option line' has been specified}{\line}
{\line}
{\tab}{\cf5 {\cf5 column}{\cf1 :} {\cf4 INTEGER_32}}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  Column number of last token read when}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  '%option line' has been specified}{\line}
{\line}
{\tab}{\cf5 {\cf5 position}{\cf1 :} {\cf4 INTEGER_32}}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  Position of last token read (i.e. number of}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  characters from the start of the input source)}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  when '%option position' has been specified}{\line}
{\line}
{\tab}{\cf5 {\cf5 pushed_start_condition_count}{\cf1 :} {\cf4 INTEGER_32}}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  Number of start conditions already pushed (and not popped yet)}{\line}
{\tab}{\line}
{\b\cf6 feature} {\cf3 --}{\cf3  Setting}{\line}
{\line}
{\tab}{\cf5 {\cf5 set_start_condition} {\cf1 (}{\cf5 a_start_condition}{\cf1 :} {\cf4 INTEGER_32}{\cf1 )}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  Set }{\cf5 start_condition}{\cf3  to }{\cf5 a_start_condition}{\cf3 .}{\line}
}{\line}
{\tab}{\cf5 {\cf5 push_start_condition} {\cf1 (}{\cf5 a_start_condition}{\cf1 :} {\cf4 INTEGER_32}{\cf1 )}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  Set start condition and add previous to stack.}{\line}
}{\line}
{\tab}{\cf5 {\cf5 pop_start_condition}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  Restore previous start condition.}{\line}
}{\tab}{\line}
{\b\cf6 feature} {\cf3 --}{\cf3  Element change}{\line}
{\line}
{\tab}{\cf5 {\cf5 append_text_to_string} {\cf1 (}{\cf5 a_string}{\cf1 :} {\cf4 STRING_8}{\cf1 )}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  Append }{\cf5 text}{\cf3  at end of }{\cf5 a_string}{\cf3 .}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  (For efficiency reason, this feature bypasses the}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  call to }{\cf5 text}{\cf3  and directly copies the characters}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  from the input buffer.)}{\line}
}{\line}
{\tab}{\cf5 {\cf5 append_text_substring_to_string} {\cf1 (}{\cf5 s}{\cf1 ,} {\cf5 e}{\cf1 :} {\cf4 INTEGER_32}{\cf1 ;} {\cf5 a_string}{\cf1 :} {\cf4 STRING_8}{\cf1 )}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  Append }{\cf5 text_substring}{\cf3  at end of }{\cf5 a_string}{\cf3 .}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  (For efficiency reason, this feature bypasses}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  the call to }{\cf5 text_substring}{\cf3  and directly copies}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  the characters from the input buffer.)}{\line}
}{\line}
{\tab}{\cf5 {\cf5 more}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  Tell scanner to append the next matched token}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  to current value of }{\cf5 text}{\cf3  instead of}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  replacing it.}{\line}
}{\line}
{\tab}{\cf5 {\cf5 less} {\cf1 (}{\cf5 n}{\cf1 :} {\cf4 INTEGER_32}{\cf1 )}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  Return all but the first }{\cf5 n}{\cf3  matched}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  characters back to }{\cf5 input_buffer}{\cf3 .}{\line}
}{\line}
{\tab}{\cf5 {\cf5 unread_character} {\cf1 (}{\cf5 c}{\cf1 :} {\cf4 CHARACTER_8}{\cf1 )}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  Put }{\cf5 c}{\cf3  back to }{\cf5 input_buffer}{\cf3 . This will alter both}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  }{\cf5 text}{\cf3  and the content of }{\cf5 input_buffer}{\cf3 .}{\line}
}{\line}
{\tab}{\cf5 {\cf5 read_character}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  Read a character from }{\cf5 input_buffer}{\cf3 .}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  Make result available in }{\cf5 last_character}{\cf3 .}{\line}
}{\tab}{\line}
{\b\cf6 feature} {\cf3 --}{\cf3  Input}{\line}
{\line}
{\tab}{\cf5 {\cf5 set_input_buffer} {\cf1 (}{\cf5 a_buffer}{\cf1 :} {\b\cf6 like} {\cf5 input_buffer}{\cf1 )}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  Set }{\cf5 input_buffer}{\cf3  to }{\cf5 a_buffer}{\cf3 .}{\line}
}{\line}
{\tab}{\cf5 {\cf5 flush_input_buffer}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  Flush }{\cf5 input_buffer}{\cf3 . }{\cf5 input_buffer}{\cf3  will be automatically}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  refilled unless end of file has been found.}{\line}
}{\tab}{\line}
{\b\cf6 feature} {\cf3 --}{\cf3  Debugging}{\line}
{\line}
{\tab}{\cf5 {\cf5 print_last_token}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  Print to standard error debug information}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  about the last token read. Can be redefined}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  in descendant classes to print more information.}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  (Called at the end of }{\cf5 read_token}{\cf3  when compiled}{\line}
{\tab}{\tab}{\tab}{\cf3 --}{\cf3  with 'debug ("GELEX")' enabled).}{\line}
}{\tab}{\line}
{\b\cf6 invariant}{\line}
{\tab}{\cf1 yy_content_not_void}{\cf1 :} {\cf5 yy_content} {\cf1 /=} {\b\cf6 Void}{\line}
{\tab}{\cf1 yy_line_positive}{\cf1 :} {\cf5 yy_line} {\cf1 >=} 1{\line}
{\tab}{\cf1 yy_column_positive}{\cf1 :} {\cf5 yy_column} {\cf1 >=} 1{\line}
{\tab}{\cf1 yy_position_positive}{\cf1 :} {\cf5 yy_position} {\cf1 >=} 1{\line}
{\tab}{\cf1 yy_pushed_start_conditions_not_void}{\cf1 :} {\cf5 yy_pushed_start_conditions} {\cf1 /=} {\b\cf6 Void}{\line}
{\line}
{\b\cf6 end} {\cf3 --} {\cf3 class }{\cf4 YY_SCANNER_SKELETON}}
{\line}
{\cf3 {\tab}{\tab}{\tab}-- Generated by ISE Eiffel --}
{\line}
{\cf3{\tab}{\tab}{\tab}-- For more details: http://www.eiffel.com --}
}}
{\line}
